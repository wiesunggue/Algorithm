# BFS 관련 유용한 기법들

# 15-퍼즐
# 숫자를 하나씩 옮기면서 1부터 15까지 4*4의 격자안에 정렬하기 문제
# 너비 우선 탐색으로 탐색 여부를 딕셔너리에 저장하면서 순차적으로 탐색

# 1. 양방향 탐색
# 정방향 탐색과 역방향 탐색을 bfs로 동시에 진행하면 3^20짜리 문제를 3^10 * 3^10 의 문제로 변환할 수 있음(O(a^b)의 문제를 O(a^b/2) 로 변환할 수 있음)
# 정방향이면 양수, 역방향이면 음수를 저장 -> 시작점을 1과 -1로 저장해야 하고, 만나는 지점에서 절댓값 합에 대해서 1를 빼주어야 함
# 양방향 탐색의 조건
# 1) 양방향으로 연결된 양방향 그래프여야 함
# 2) 시간복잡도가 크면 탐색하면 안됨
# 3) 탐색의 최대 깊이가 정해져 있어야 함(정답의 상태를 알아야 함)

# 2. 점점 깊어지는 탐색(IDS, Iteratively Deepening Search)
# 임의의 탐색 깊이 l을 정한 후 이 제한보다 짧은 경로가 존재하는지를 깊이 우선 탐색으로 확인
# 답을 찾으면 성공이고 아니면 l을 늘려서 해당 탐색 재시행

# 이렇게 하면 dfs에서 메모리 효율성의 이점과 bfs의 최단거리 이점을 동시에 취할 수 있음
# 단점으로는 중복 탐색으로 인하여 BFS가 b^d 라면 IDS는 (d+1)*b+(d)*b^2+(d-1)*b^3+....+b^d 가 되어야 함


# 3. 추가적인 최적화
# 모든 타일에 대해 현재 위치와 목표 위치 사이의 맨해튼 거리를 더해서 가지치기
# 맨해튼 거리는 |x1-x2|+|y1-y2|로 정의됨
# 이 거리가 현재 찾은 위치에 추가해서 최단 거리나 깊이 제한을 초과한다면 해당 분기는 탐색하지 않아도 됨

# 4. 상태 객체의 구현
# 1) 모든 상태는 16!로 구현되니 일대일 대응 함수를 정의할 수 있음
# 2) 0~15의 값은 4비트로 저장할 수 있으므로 64비트에 16칸의 상태를 모두 저장할 수 있음


# 탐색 방법 선택하기
# 1. 상태 공간에서 최단 경로를 찾는 경우 BFS를 우선적으로 고려해야 함, 하지만, 탐색의 깊이 한계가 없거나 너무 깊어서 메모리 사용량을 초과하지 않을지 확인
# 2. 최단 경로를 찾는데 탐색의 깊이가 정해져 있고, 너비 우선탐색을 하기에는 시간이 부족하다면 양방향 탐색을 고려(역방향으로 이동이 가능한 경우에만)
# 3. 두 방법 모두 메모리, 시간문제로 인해 활용하지 못하는 경우 점점 깊어지는 탐색을 활용


# 하노이의 탑
# 4개의 기둥이 있고, 최대 다이스는 12개 현재 상태와 최종 상태가 주어질 때 해당 상태로 변환하기 위한 최소 움직임 횟수를 게산하기

# 상태 공간 만들기
# 항상 크기순으로 정렬되므로 2비트를 이용해서 하나의 원반을 표현(4개의 기둥)  -> 24비트로 12개의 원반과 기둥 위치를 표현할 수 있음

# 양방향 탐색
# 양방향 탐색으로 수행 시간 최적화
